\documentclass{book}
\usepackage{pervasives}

\title{Stopify: User's Manual}
\author{Samuel Baxter, Arjun Guha, Rachit Nigam, and Joe~Gibbs Politz}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}

Stopify is a JavaScript-to-JavaScript compiler that makes JavaScript a better
target language for high-level languages and web-based programming tools.
Stopify enhances JavaScript with debugging abstractions, blocking operations,
and support for long-running computations.

Suppose you have a compiler \emph{C} from language \emph{L} to JavaScript. You
can apply Stopify to the output of \emph{C} and leave \emph{C} almost entirely
unchanged. Stopify will provide the following features:

\begin{enumerate}

\item Stopify will support long-running \emph{L} programs without freezing the
browser tab. In particular, programs can access the DOM and are not limited to
Web Workers.

\item Stopify can pause or terminate an \emph{L} program, even if it is an
infinite loop.

\item Stopify can set breakpoints or single-step through the \emph{L} program,
if \emph{C} generates source maps.

\item Stopify can simulate an arbitrarily deep stack and proper tail calls.
This feature is necessary to run certain functional programs in the browser.

\item Stopify can simulate blocking operations on the web.

\end{enumerate}

In many cases, it is possible to ``blindly'' use Stopify by applying it to the
output of your compiler. However, Stopify will compile faster, produce faster
code, and support more features, if your compiler cooperates with Stopify in
particular ways. This manual will guide you through using Stopify with your own
compiler.

\section{Quick Start}

\begin{figure}
\lstset{language=js}
\begin{lstlisting}
const elt = document.createElement("div");
document.body.appendChild(elt);

var i = 0;
var j = 0;
while(true) {
  if (i++ == 10000000) {
    j++;
    elt.innerText = "Still runninng ... " + (new Date());
    i = 0;
  }
}
\end{lstlisting}
\caption{This program will make any web browser crash.\label{trivial-periodic}}
\end{figure}

This section guides you through installing Stopify and applying it to a simple
JavaScript program that runs forever and periodically prints the current time
(\cref{trivial-periodic}). However, since the program never yields
control to the browser's event loop (e.g., using \texttt{setTimeout}), nothing
will appear on the page and the browser tab will eventually crash. Stopify will
make this program behave more naturally and actually show output.

\begin{enumerate}

\item Install the Stopify executable using NPM (or Yarn):
\lstset{language=console}
\begin{lstlisting}
npm install -g stopify
\end{lstlisting}

\item Save the program in \cref{trivial-periodic} to the file
 \texttt{input.js}:


\item Use the Stopify compiler to stopify the program:

\lstset{language=console}
\begin{lstlisting}
stopify input.js output.js
\end{lstlisting}

\item The Stopify installation includes a copy of the Stopify runtime system
(\texttt{stopify.bundle.js})
Look up the path using the following command:

\lstset{language=console}
\begin{lstlisting}
stopify-path stopify.bundle.js
\end{lstlisting}


\item Create
that first loads the Stopify runtime system and then uses the Stopify runtime
to load \texttt{output.js}. \Cref{trivial-driver} shows such a page, but
make sure to adjust the path of \texttt{stopify.bundle.js} to the path
produced in the previous step.

\end{enumerate}

\begin{figure}
\lstset{language=console}
\begin{lstlisting}
<html>
  <body>
    <script src="stopify.bundle.js"></script>
    <script>
    var runner = stopify.stopify("output.js", {
      estimator: "reservoir",
      yieldInterval: 100,
      resampleInterval: 100,
      timePerElapsed: 1
    });

    runner.run(() => console.log("done"));
    </script>
  </body>
</html>
\end{lstlisting}
\caption{A basic driver to run a stopified program.\label{trivial-driver}}
\end{figure}
  

Finally, open the webpage in any browser. You'll find that the the program
``just works'' and periodically prints the current time. In contrast, if you
load \texttt{input.js} directly, it will not print anything and will eventually
crash the browser tab.

\chapter{Compiler Configuration}

You can configure the Stopify compiler in several ways.

\section{Transformation}

Stopify uses first-class continuations as a primitive to implement its
execution control features. Stopify can represent continuations in several
ways; the fastest approach depends on the application and the browser. The
valid options are `lazy`, `retval`, and `eager`. For most cases, we recommend
using `lazy`.

   There are two additional options that are only useful for benchmarking and debugging: `original` leaves the input program unchanged and `fudge` applies all transformations with the exception of continuation instrumentation.

   Command-line: `--transform`

   JavaScript API: `captureMethod`

- **Constructor encoding**. Stopify implements two mechanisms to support
   suspending execution within the dynamic extent of a constructor call.

   - The `wrapper` mechanism desugars all `new` expressions to ordinary function
      calls (using `Object.create`).

   - The `direct` mechanism keeps `new` expressions intact but instruments
     all functions to check if they are invoked as constructors 
     (using `new.target`).

  The fastest approach depends on the browser. We recommend using `wrapper`.

  Command-line: `--new`

  JavaScript API: `newMethod`

- **Implicit operations**. Stopify can suspend execution
  within user-written `valueOf()` and `toString()` methods
  that JavaScript invokes implicitly.

  For example, the following program is an infinite loop
  in JavaScript:

  ```javascript
  var x = { toString: function() { while(true) { } } };
  x + 1;
  ```

  With the implicit operations flag is set to `es5`,
  Stopify will  be able to gracefully suspend the program
  above. With the flag set to `sane`, Stopify will not be able to detect the
  the infinite loop. We have found that most source language compilers do not
  rely on implicit operations, thus it is usually safe to use `sane`.

  Command-line: `--es` (default: `sane`)

  JavaScript API: `es`

- **Arguments object aliasing.** The `arguments` object makes it difficult
  from Stopify to suspend execution. Stopify supports `arguments` in full, but
  it also supports two simple special cases that improve performance.

  - `simple`: use this option if the program (1) does not use `arguments` to
    access declared formal arguments and (2) only reads additional
    arguments using the `arguments` object.

  - `faithful`: use this option if the program (1) does not use `arguments`
    to access declared formal arguments and (2) may read or write additional
    arguments using the `arguments` object.

  - `full`: use this option for full support of JavaScript's `arguments` object.

  Command-line: `--js-args` (default: `simple`)

  JavaScript API: `jsArgs`

- **Higher-order functions.** Programs cannot use higher-order functions
  (e.g., `.map`, `.filter`, etc.) with Stopify, since Stopify cannot
  instrument native code.

  - `builtin`: with this option, Stopify assumes that the program does not
    use any native higher-order functions.

  - `fill`: with this option, Stopify rewrites programs that use native
    higher-order functions to use polyfills written in JavaScript.

  Command-line: `--hofs` (default: `builtin`)

  JavaScript API: `hofs`

- **Getters and setters**. Programs that suspend execution within
  getters/setters incur a lot  of overhead with Stopify.

  - `true`: with this option, Stopify instruments the program to support
    suspension within getters/setters.

  - `false`: with this option, Stopify assumes that the program does not
    suspend execution within getters/setters.

  Command-line: `--getters` to enable and `--no-getters` to disable
  (default: `--no-getters`)

  JavaScript API: `getters`

- **Single-stepping and breakpointing.** Stopify can support single-stepping
  and breakpointing, but this requires more instrumentation.

  Command-line: `--debug` to enable and `--no-debug` to disable
  (default `--no-debug`)

  JavaScript API: boolean flag `.debug`

- **Node.js support.** Stopify is designed to produce programs that work in
  the browser, but it can also be helpful to run programs in Node for debugging
  and testing. For the browser, the compiler produces programs with a free
  variable `stopify` that must be bound to the runtime system. For Node.js,
  the compiler produces a program that uses `require` to load the runtime
  system.

\end{document}